<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; }
        a.toc-link:hover { color: #000; text-decoration: underline; }
        a.toc-link.active { color: #d63384; font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; align-items: center; margin-top: 60px; padding-top: 20px; border-top: 1px solid #eee; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: bold; padding: 10px 20px; border: 1px solid #3498db; border-radius: 4px; transition: all 0.2s; cursor: pointer; }
        .nav-btn:hover { background: #3498db; color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: #ccc; color: #ccc; }
        .nav-btn.loading { opacity: 0.6; cursor: wait; }
        
        /* Illustration Controls */
        .illustration-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 20px; }
        .illustration-btn { background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-weight: bold; font-family: -apple-system, sans-serif; }
        .illustration-btn:hover { background: #218838; }
        .illustration-btn:disabled { background: #6c757d; cursor: not-allowed; }
        .illustration-status { font-size: 0.9em; color: #666; }
        .spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 8px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* TTS Play Button - Hidden by default, shown on paragraph hover */
        .tts-paragraph-wrapper {
            position: relative;
            margin-bottom: 1.5em;
            padding-right: 40px;  /* Make room for button and extend hover zone */
            margin-right: -40px;  /* Compensate for padding to maintain text alignment */
        }

        .tts-paragraph-wrapper p {
            margin-bottom: 0;  /* Remove margin since wrapper handles it */
        }

        .tts-paragraph-wrapper .tts-play-btn {
            display: none;  /* Hidden until hover */
            position: absolute;
            right: 5px;  /* Position inside the wrapper's padding area */
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            background: #3498db;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
            z-index: 10;
            align-items: center;
            justify-content: center;
        }

        .tts-paragraph-wrapper:hover .tts-play-btn {
            display: flex;  /* Show on wrapper hover */
        }

        /* Keep button visible when loading or playing */
        .tts-paragraph-wrapper .tts-play-btn.loading,
        .tts-paragraph-wrapper .tts-play-btn.playing {
            display: flex !important;  /* Always show when loading or playing */
        }

        .tts-play-btn:hover {
            background: #2980b9;
            transform: translateY(-50%) scale(1.1);
        }

        /* Play icon (triangle) */
        .tts-play-btn::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 8px solid white;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            margin-left: 2px;
        }

        /* Playing state (pause icon - two bars) */
        .tts-play-btn.playing {
            background: #e74c3c;
        }

        .tts-play-btn.playing::before {
            content: '';
            border: none;
            width: 2.5px;
            height: 10px;
            background: white;
            margin: 0;
            margin-left: -5px;  /* Shift left to visually center the two-bar icon */
            box-shadow: 4.5px 0 0 white;  /* Second bar created with box-shadow */
            border-radius: 0.5px;  /* Slight rounding for smoother appearance */
        }

        /* Loading state */
        .tts-play-btn.loading {
            background: #95a5a6;
        }

        .tts-play-btn.loading::before {
            content: '⋯';
            border: none;
            color: white;
            font-size: 18px;
            margin: 0;
            width: auto;
            height: auto;
        }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">← Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <!-- Illustration Controls at Top -->
            <div class="illustration-controls" style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                <button id="generate-illustrations-btn" class="illustration-btn" onclick="generateIllustrations()">
                    <span id="illustration-btn-text">Generate Illustrations</span>
                </button>
                <div id="illustration-status" class="illustration-status"></div>
            </div>
            
            <div class="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">← Previous</a>
                {% else %}
                    <span class="nav-btn disabled">← Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next →</a>
                {% else %}
                    <span class="nav-btn disabled">Next →</span>
                {% endif %}
            </div>
        </div>
    </div>

    <script>
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "/read/{{ book_id }}/" + idx;
                // If there was an anchor, we could try to scroll to it,
                // but simple page loads often lose anchor position without extra JS.
                // Let's just go to the page.
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        // Illustration generation
        const bookId = "{{ book_id }}";
        const chapterIndex = {{ chapter_index }};
        const hasIllustrations = {{ 'true' if has_illustrations else 'false' }};

        // Check illustration status on load
        async function checkIllustrationStatus() {
            console.log('[DEBUG] Checking illustration status for chapter', chapterIndex);
            try {
                const response = await fetch(`/read/${bookId}/${chapterIndex}/illustration-status`);
                console.log('[DEBUG] Status response:', response.status, response.statusText);
                const data = await response.json();
                console.log('[DEBUG] Status data:', JSON.stringify(data, null, 2));
                
                const statusDiv = document.getElementById('illustration-status');
                const btn = document.getElementById('generate-illustrations-btn');
                
                if (data.has_illustrations) {
                    statusDiv.textContent = `✓ ${data.image_count} illustrations available`;
                    const btnText = document.getElementById('illustration-btn-text');
                    if (btnText) {
                        btnText.textContent = 'Regenerate Illustrations';
                    }
                } else {
                    statusDiv.textContent = 'No illustrations yet';
                }
            } catch (error) {
                console.error('[DEBUG] Error checking illustration status:', error);
            }
        }

        async function generateIllustrations() {
            console.log('[DEBUG] ===== Starting illustration generation =====');
            console.log('[DEBUG] Book ID:', bookId);
            console.log('[DEBUG] Chapter Index:', chapterIndex);
            
            const btn = document.getElementById('generate-illustrations-btn');
            const btnText = document.getElementById('illustration-btn-text');
            const statusDiv = document.getElementById('illustration-status');
            
            // Disable button and show loading
            btn.disabled = true;
            btnText.innerHTML = '<span class="spinner"></span>Generating...';
            statusDiv.textContent = 'Generating illustrations (this may take a minute)...';
            
            try {
                const url = `/read/${bookId}/${chapterIndex}/generate-illustrations`;
                console.log('[DEBUG] POST request to:', url);
                
                const response = await fetch(url, {
                    method: 'POST'
                });
                
                console.log('[DEBUG] Response status:', response.status, response.statusText);
                console.log('[DEBUG] Response headers:', Object.fromEntries(response.headers.entries()));
                
                const responseData = await response.json().catch(async () => {
                    const text = await response.text();
                    return { text };
                });
                console.log('[DEBUG] Response data:', JSON.stringify(responseData, null, 2));
                
                if (response.ok) {
                    console.log('[DEBUG] Generation started, beginning polling...');
                    // Poll for completion
                    let attempts = 0;
                    const maxAttempts = 180; // 180 seconds (3 minutes) - generation can take a while
                    
                    const pollInterval = setInterval(async () => {
                        attempts++;
                        console.log(`[DEBUG] Polling attempt ${attempts}/${maxAttempts}`);
                        try {
                            const statusResponse = await fetch(`/read/${bookId}/${chapterIndex}/illustration-status`);
                            const statusData = await statusResponse.json();
                            console.log(`[DEBUG] Poll ${attempts} - Status:`, JSON.stringify(statusData, null, 2));

                            // Check that we have all 3 illustrations (not just some)
                            if (statusData.has_illustrations && statusData.image_count === 3) {
                                console.log('[DEBUG] ✓ All 3 illustrations found! Stopping poll.');
                                clearInterval(pollInterval);
                                statusDiv.textContent = '✓ Illustrations generated! Refreshing page...';
                                // Refresh page after a short delay
                                setTimeout(() => {
                                    window.location.reload();
                                }, 1000);
                            } else if (attempts >= maxAttempts) {
                                console.log('[DEBUG] Max attempts reached, stopping poll.');
                                clearInterval(pollInterval);
                                btn.disabled = false;
                                btnText.textContent = 'Generate Illustrations';
                                statusDiv.textContent = 'Generation taking longer than expected. Please refresh the page in a moment.';
                            }
                        } catch (error) {
                            console.error('[DEBUG] Error polling status:', error);
                        }
                    }, 1000);
                } else {
                    console.error('[DEBUG] Response not OK:', response.status, responseData);
                    throw new Error(`Failed to start generation: ${response.status} - ${JSON.stringify(responseData)}`);
                }
            } catch (error) {
                console.error('[DEBUG] ===== Error generating illustrations =====');
                console.error('[DEBUG] Error details:', error);
                console.error('[DEBUG] Error stack:', error.stack);
                btn.disabled = false;
                btnText.textContent = 'Generate Illustrations';
                statusDiv.textContent = 'Error: ' + error.message;
            }
        }

        // Check status on page load
        checkIllustrationStatus();

        // ============= TTS FUNCTIONALITY =============

        // TTS global state
        const ttsCache = new Map();  // Map para_hash -> audio_path
        let currentAudio = null;     // Current playing audio element

        // Initialize TTS on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeTTS();
        });

        function initializeTTS() {
            console.log('[TTS DEBUG] Initializing TTS for paragraphs...');

            // Find all paragraphs in book content
            const paragraphs = document.querySelectorAll('.book-content p');
            console.log(`[TTS DEBUG] Found ${paragraphs.length} paragraphs`);

            let buttonCount = 0;
            paragraphs.forEach((para, index) => {
                // Skip empty paragraphs
                const text = para.textContent.trim();
                if (!text || text.length < 10) {
                    return;
                }

                // Skip if already wrapped (in case of re-initialization)
                if (para.parentElement.classList.contains('tts-paragraph-wrapper')) {
                    return;
                }

                // Create wrapper div
                const wrapper = document.createElement('div');
                wrapper.className = 'tts-paragraph-wrapper';

                // Replace paragraph with wrapper, then put paragraph inside wrapper
                para.parentNode.insertBefore(wrapper, para);
                wrapper.appendChild(para);

                // Create play button
                const playBtn = document.createElement('button');
                playBtn.className = 'tts-play-btn';
                playBtn.setAttribute('title', 'Play audio');
                playBtn.onclick = (e) => {
                    e.stopPropagation();
                    handleTTSClick(playBtn, text);
                };

                // Add button to wrapper (not paragraph)
                wrapper.appendChild(playBtn);
                wrapper.setAttribute('data-tts-enabled', 'true');
                buttonCount++;
            });

            console.log(`[TTS DEBUG] Added ${buttonCount} TTS buttons`);
        }

        // Generate hash for paragraph text (client-side)
        async function generateSimpleHash(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);

            // Use SHA-256 (MD5 not available in browsers, but we'll use first 16 chars)
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            // Take first 16 characters to match backend MD5 length
            return hashHex.substring(0, 16);
        }

        async function handleTTSClick(button, text) {
            console.log('[TTS DEBUG] TTS button clicked');

            // If already playing this paragraph, stop it
            if (currentAudio && button.classList.contains('playing')) {
                console.log('[TTS DEBUG] Stopping current audio');
                stopCurrentAudio();
                return;
            }

            // Stop any other playing audio
            if (currentAudio) {
                console.log('[TTS DEBUG] Stopping other audio');
                stopCurrentAudio();
            }

            // Generate hash for this paragraph
            const paraHash = await generateSimpleHash(text);
            console.log(`[TTS DEBUG] Paragraph hash: ${paraHash}`);

            // Check cache first
            if (ttsCache.has(paraHash)) {
                console.log('[TTS DEBUG] Found in cache');
                playAudio(button, ttsCache.get(paraHash));
                return;
            }

            // Show loading state
            button.classList.add('loading');
            button.setAttribute('title', 'Generating audio...');

            try {
                // Request TTS generation
                console.log('[TTS DEBUG] Requesting TTS generation...');
                const response = await fetch(`/read/${bookId}/generate-tts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[TTS DEBUG] Response:', data);

                if (data.status === 'cached') {
                    // Audio already available
                    console.log('[TTS DEBUG] Audio was cached on server');
                    ttsCache.set(paraHash, data.audio_path);
                    playAudio(button, data.audio_path);
                } else if (data.status === 'generating') {
                    // Poll for completion
                    console.log('[TTS DEBUG] Starting polling for generation...');
                    pollTTSStatus(button, data.para_hash);
                }
            } catch (error) {
                console.error('[TTS ERROR] TTS generation error:', error);
                button.classList.remove('loading');
                button.setAttribute('title', 'Error generating audio');
                // Show error state briefly
                button.style.background = '#e74c3c';
                setTimeout(() => {
                    button.style.background = '';
                }, 2000);
            }
        }

        async function pollTTSStatus(button, paraHash) {
            const maxAttempts = 30;  // 30 seconds max
            let attempts = 0;

            const pollInterval = setInterval(async () => {
                attempts++;
                console.log(`[TTS DEBUG] Polling attempt ${attempts}/${maxAttempts}`);

                try {
                    const response = await fetch(`/read/${bookId}/tts-status/${paraHash}`);
                    const data = await response.json();
                    console.log(`[TTS DEBUG] Poll ${attempts} - Status:`, data);

                    if (data.ready && data.audio_path) {
                        console.log('[TTS DEBUG] Audio ready!');
                        clearInterval(pollInterval);
                        ttsCache.set(paraHash, data.audio_path);
                        playAudio(button, data.audio_path);
                    } else if (attempts >= maxAttempts) {
                        console.log('[TTS DEBUG] Max attempts reached');
                        clearInterval(pollInterval);
                        button.classList.remove('loading');
                        button.setAttribute('title', 'Generation timeout - try again');
                    }
                } catch (error) {
                    console.error('[TTS ERROR] Polling error:', error);
                    clearInterval(pollInterval);
                    button.classList.remove('loading');
                }
            }, 1000);
        }

        function playAudio(button, audioPath) {
            console.log('[TTS DEBUG] Playing audio:', audioPath);

            button.classList.remove('loading');
            button.classList.add('playing');
            button.setAttribute('title', 'Stop audio');

            // Create and play audio
            currentAudio = new Audio(`/read/${bookId}/${audioPath}`);
            currentAudio.currentButton = button;

            currentAudio.onended = () => {
                console.log('[TTS DEBUG] Audio playback ended');
                button.classList.remove('playing');
                button.setAttribute('title', 'Play audio');
                currentAudio = null;
            };

            currentAudio.onerror = (e) => {
                console.error('[TTS ERROR] Audio playback error:', e);
                button.classList.remove('playing');
                button.setAttribute('title', 'Playback error');
                currentAudio = null;
            };

            currentAudio.play().catch(err => {
                console.error('[TTS ERROR] Audio play error:', err);
                button.classList.remove('playing');
            });
        }

        function stopCurrentAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                if (currentAudio.currentButton) {
                    currentAudio.currentButton.classList.remove('playing');
                    currentAudio.currentButton.setAttribute('title', 'Play audio');
                }
                currentAudio = null;
            }
        }
    </script>
</body>
</html>
