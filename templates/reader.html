<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3498db',
                        'primary-dark': '#2980b9',
                    }
                }
            }
        }
    </script>
</head>
<body class="flex flex-col lg:flex-row h-screen overflow-hidden font-serif bg-white">

    <!-- Mobile Header -->
    <div class="lg:hidden fixed top-0 left-0 right-0 bg-white border-b border-gray-200 z-40 px-4 py-3 flex items-center gap-3">
        <button id="mobile-menu-btn" class="p-2 -ml-2 rounded hover:bg-gray-100">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
        </button>
        <h1 class="text-lg font-semibold truncate">{{ book.metadata.title }}</h1>
    </div>

    <!-- Mobile Overlay -->
    <div id="mobile-overlay" class="lg:hidden fixed inset-0 bg-black/50 z-40 hidden"></div>

    <!-- SIDEBAR -->
    <div id="sidebar" class="fixed lg:static inset-y-0 left-0 z-50 w-80 lg:w-[300px] transform -translate-x-full lg:translate-x-0 transition-transform duration-300 ease-in-out bg-gray-50 border-r border-gray-200 overflow-y-auto p-5 lg:flex-shrink-0">
        <!-- Close button for mobile -->
        <button id="close-sidebar-btn" class="lg:hidden absolute top-4 right-4 p-2 rounded hover:bg-gray-200">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
        </button>

        <a href="/" class="block mb-5 text-primary no-underline text-sm">← Back to Library</a>

        <!-- Book Title with Menu -->
        <div class="relative mb-4 pb-2.5 border-b border-gray-300">
            <div class="flex items-center gap-2 group">
                <div class="font-sans font-bold text-gray-700 flex-1">{{ book.metadata.title }}</div>

                <!-- Book Menu Button -->
                <button
                    id="book-menu-btn"
                    class="p-1.5 rounded hover:bg-gray-200 transition-colors flex-shrink-0 opacity-0 group-hover:opacity-100"
                    onclick="toggleBookMenu(event)"
                    title="Book actions">
                    <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"/>
                    </svg>
                </button>
            </div>

            <!-- Book Menu Dropdown -->
            <div
                id="book-menu-dropdown"
                class="hidden absolute top-full left-0 mt-2 bg-white border border-gray-200 rounded-lg shadow-xl min-w-[200px] z-50">
                <a
                    href="/export/{{ book_id }}"
                    class="block w-full px-4 py-2.5 text-left text-sm text-gray-800 hover:bg-gray-50 transition-colors rounded-t-lg">
                    Export Book as EPUB
                </a>
                <div class="h-px bg-gray-200"></div>
                <button
                    class="block w-full px-4 py-2.5 text-left text-sm text-gray-800 hover:bg-gray-50 transition-colors rounded-b-lg"
                    onclick="generateAllIllustrations(); closeBookMenu();">
                    Generate All Illustrations
                </button>
            </div>
        </div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="list-none pl-0 m-0">
            {% for item in items %}
                <li class="mb-2">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')" data-file-href="{{ item.file_href }}"
                       class="toc-link flex items-center gap-1.5 py-1 text-gray-700 hover:text-black hover:underline text-sm leading-relaxed transition-colors {% if is_active %}text-pink-600 font-bold{% endif %}">
                        <span class="flex-1">{{ item.title }}</span>
                        <svg class="illustration-icon hidden w-3.5 h-3.5 text-primary flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M4 3C2.89543 3 2 3.89543 2 5V15C2 16.1046 2.89543 17 4 17H16C17.1046 17 18 16.1046 18 15V5C18 3.89543 17.1046 3 16 3H4ZM4 5H16V15H4V5Z"/>
                            <circle cx="7" cy="8" r="1.5"/>
                            <path d="M13 13L10 10L7 13H13Z"/>
                        </svg>
                    </a>

                    {% if item.children %}
                        <ul class="list-none pl-3 lg:pl-5 m-0">
                            {% for child in item.children %}
                            <li class="mb-2">
                                {% set is_active_child = current_chapter.href == child.file_href %}
                                <a href="#" onclick="findAndGo('{{ child.file_href }}')" data-file-href="{{ child.file_href }}"
                                   class="toc-link flex items-center gap-1.5 py-1 text-gray-700 hover:text-black hover:underline text-sm leading-relaxed transition-colors {% if is_active_child %}text-pink-600 font-bold{% endif %}">
                                    <span class="flex-1">{{ child.title }}</span>
                                    <svg class="illustration-icon hidden w-3.5 h-3.5 text-primary flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                        <path d="M4 3C2.89543 3 2 3.89543 2 5V15C2 16.1046 2.89543 17 4 17H16C17.1046 17 18 16.1046 18 15V5C18 3.89543 17.1046 3 16 3H4ZM4 5H16V15H4V5Z"/>
                                        <circle cx="7" cy="8" r="1.5"/>
                                        <path d="M13 13L10 10L7 13H13Z"/>
                                    </svg>
                                </a>
                            </li>
                            {% endfor %}
                        </ul>
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- Floating Action Button (Fixed Lower Right) -->
    <div class="fixed bottom-6 right-6 z-50">
        <!-- Status Text (shown above the button) -->
        <div id="illustration-status" class="text-xs text-gray-600 bg-white px-3 py-1.5 rounded-full shadow-md mb-2 text-center whitespace-nowrap hidden"></div>

        <!-- Dropdown Menu (appears above button) -->
        <div class="hidden absolute bottom-full right-0 mb-3 bg-white border border-gray-200 rounded-lg shadow-xl min-w-[220px]" id="actions-dropdown-menu">
            <button class="block w-full px-4 py-2.5 text-left text-sm text-gray-800 hover:bg-gray-50 transition-colors disabled:text-gray-400 disabled:cursor-not-allowed disabled:bg-transparent rounded-t-lg" id="generate-illustrations-btn" onclick="generateIllustrations(); closeDropdown();">
                <span id="illustration-btn-text">Generate Illustrations</span>
            </button>
            <div class="h-px bg-gray-200"></div>
            <button class="block w-full px-4 py-2.5 text-left text-sm text-gray-800 hover:bg-gray-50 transition-colors rounded-b-lg" onclick="exportChapter(); closeDropdown();">
                Export Chapter as EPUB
            </button>
        </div>

        <!-- Circular Action Button -->
        <button class="w-14 h-14 bg-primary hover:bg-primary-dark text-white rounded-full shadow-lg hover:shadow-xl flex items-center justify-center transition-all hover:scale-110" onclick="toggleDropdown()" id="actions-menu-btn" title="Actions">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/>
            </svg>
        </button>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main" class="flex-1 overflow-y-auto pt-14 lg:pt-0 scroll-smooth">
        <div class="content-container max-w-3xl mx-auto px-4 sm:px-6 lg:px-10 py-8 sm:py-12 lg:py-15 text-lg leading-relaxed text-gray-800">

            <div class="book-content prose prose-lg max-w-none prose-img:mx-auto prose-p:text-justify prose-h1:font-sans prose-h2:font-sans prose-h3:font-sans prose-h1:text-gray-800 prose-h2:text-gray-800 prose-h3:text-gray-800 prose-h1:mt-6 prose-h2:mt-6 prose-h3:mt-6 prose-p:mb-6">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav flex justify-between items-center mt-15 pt-5 border-t border-gray-200 font-sans">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="inline-block text-primary font-bold px-5 py-2.5 border border-primary rounded hover:bg-primary hover:text-white transition-all">← Previous</a>
                {% else %}
                    <span class="inline-block opacity-50 pointer-events-none border-gray-300 text-gray-300 font-bold px-5 py-2.5 border rounded">← Previous</span>
                {% endif %}

                <span class="text-gray-500 px-2.5">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="inline-block text-primary font-bold px-5 py-2.5 border border-primary rounded hover:bg-primary hover:text-white transition-all">Next →</a>
                {% else %}
                    <span class="inline-block opacity-50 pointer-events-none border-gray-300 text-gray-300 font-bold px-5 py-2.5 border rounded">Next →</span>
                {% endif %}
            </div>
        </div>
    </div>

    <script>
        // Mobile menu controls
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('mobile-overlay');
        const openBtn = document.getElementById('mobile-menu-btn');
        const closeBtn = document.getElementById('close-sidebar-btn');

        function openSidebar() {
            sidebar.classList.remove('-translate-x-full');
            sidebar.classList.add('translate-x-0');
            overlay.classList.remove('hidden');
            document.body.classList.add('overflow-hidden');
        }

        function closeSidebar() {
            sidebar.classList.add('-translate-x-full');
            sidebar.classList.remove('translate-x-0');
            overlay.classList.add('hidden');
            document.body.classList.remove('overflow-hidden');
        }

        openBtn?.addEventListener('click', openSidebar);
        closeBtn?.addEventListener('click', closeSidebar);
        overlay?.addEventListener('click', closeSidebar);

        // Close sidebar when resizing to desktop
        window.addEventListener('resize', () => {
            if (window.innerWidth >= 1024) {
                closeSidebar();
                document.body.classList.remove('overflow-hidden');
            }
        });

        // Dropdown menu controls (chapter actions)
        function toggleDropdown() {
            const dropdown = document.getElementById('actions-dropdown-menu');
            dropdown.classList.toggle('hidden');
        }

        function closeDropdown() {
            const dropdown = document.getElementById('actions-dropdown-menu');
            dropdown.classList.add('hidden');
        }

        // Close dropdown when clicking outside
        window.addEventListener('click', function(event) {
            const dropdown = document.getElementById('actions-dropdown-menu');
            const button = document.getElementById('actions-menu-btn');

            if (!button.contains(event.target) && !dropdown.contains(event.target)) {
                closeDropdown();
            }
        });

        // Book menu controls (book-level actions in sidebar)
        function toggleBookMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('book-menu-dropdown');
            dropdown.classList.toggle('hidden');
        }

        function closeBookMenu() {
            const dropdown = document.getElementById('book-menu-dropdown');
            dropdown.classList.add('hidden');
        }

        // Close book menu when clicking outside
        window.addEventListener('click', function(event) {
            const bookDropdown = document.getElementById('book-menu-dropdown');
            const bookButton = document.getElementById('book-menu-btn');

            if (bookButton && !bookButton.contains(event.target) && bookDropdown && !bookDropdown.contains(event.target)) {
                closeBookMenu();
            }
        });

        // Generate illustrations for all chapters in the book
        async function generateAllIllustrations() {
            const totalChapters = {{ book.spine | length }};

            if (!confirm('This will generate illustrations for all ' + totalChapters + ' chapters (filtered by length). This may take 10-30 minutes. Continue?')) {
                return;
            }

            console.log('[DEBUG] Starting bulk illustration generation for all chapters');
            closeBookMenu();

            try {
                // Start batch generation
                const response = await fetch('/read/' + bookId + '/generate-all-illustrations', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to start batch generation: ' + response.statusText);
                }

                const data = await response.json();
                console.log('[DEBUG] Batch generation started:', data);

                // Store batch ID in localStorage for persistence across page navigation
                localStorage.setItem('activeBatchId_' + bookId, data.batch_id);
                localStorage.setItem('activeBatchTotal_' + bookId, data.eligible_chapters);

                // Show progress notification
                const statusDiv = document.getElementById('illustration-status');
                statusDiv.textContent = 'Generating illustrations for ' + data.eligible_chapters + ' chapters...';
                statusDiv.classList.remove('hidden');

                // Poll for progress
                pollBatchProgress(data.batch_id, data.eligible_chapters);

            } catch (error) {
                console.error('[DEBUG] Error starting batch generation:', error);
                alert('Error: ' + error.message);
            }
        }

        // Poll batch generation progress
        async function pollBatchProgress(batchId, totalChapters) {
            const statusDiv = document.getElementById('illustration-status');
            let attempts = 0;
            const maxAttempts = 1800; // 30 minutes max (checking every second)

            const pollInterval = setInterval(async () => {
                attempts++;

                try {
                    const response = await fetch('/read/' + bookId + '/batch-status/' + batchId);
                    const data = await response.json();

                    console.log('[DEBUG] Batch progress:', data);

                    if (data.status === 'completed') {
                        clearInterval(pollInterval);

                        // Clear localStorage
                        localStorage.removeItem('activeBatchId_' + bookId);
                        localStorage.removeItem('activeBatchTotal_' + bookId);

                        statusDiv.textContent = '✓ Generated ' + data.completed + ' illustrations!';
                        statusDiv.classList.add('!text-green-600');

                        // Refresh TOC icons after 2 seconds
                        setTimeout(() => {
                            updateTOCIcons();
                            statusDiv.classList.add('hidden');
                            statusDiv.classList.remove('!text-green-600');
                        }, 3000);
                    } else if (data.status === 'error') {
                        clearInterval(pollInterval);

                        // Clear localStorage
                        localStorage.removeItem('activeBatchId_' + bookId);
                        localStorage.removeItem('activeBatchTotal_' + bookId);

                        statusDiv.textContent = '✗ Error: ' + (data.error || 'Generation failed');
                        statusDiv.classList.add('!text-red-600');
                    } else if (data.status === 'in_progress') {
                        // Update progress
                        statusDiv.textContent = 'Generating ' + data.completed + '/' + data.total + ' chapters...';
                    } else if (data.status === 'not_found') {
                        // Batch not found - might be old/deleted
                        clearInterval(pollInterval);
                        localStorage.removeItem('activeBatchId_' + bookId);
                        localStorage.removeItem('activeBatchTotal_' + bookId);
                        statusDiv.classList.add('hidden');
                    } else if (attempts >= maxAttempts) {
                        clearInterval(pollInterval);
                        statusDiv.textContent = 'Timeout - refresh page to check results';
                        statusDiv.classList.add('!text-orange-600');
                    }
                } catch (error) {
                    console.error('[DEBUG] Error polling batch status:', error);
                }
            }, 1000);
        }

        // Check for active batch generation on page load
        async function checkActiveBatchGeneration() {
            const batchId = localStorage.getItem('activeBatchId_' + bookId);
            const totalChapters = localStorage.getItem('activeBatchTotal_' + bookId);

            if (!batchId) {
                console.log('[DEBUG] No active batch generation found');
                return;
            }

            console.log('[DEBUG] Found active batch generation:', batchId);

            // Check if the batch is still in progress
            try {
                const response = await fetch('/read/' + bookId + '/batch-status/' + batchId);
                const data = await response.json();

                console.log('[DEBUG] Active batch status:', data);

                if (data.status === 'in_progress') {
                    // Resume polling
                    const statusDiv = document.getElementById('illustration-status');
                    statusDiv.textContent = 'Generating ' + data.completed + '/' + data.total + ' chapters...';
                    statusDiv.classList.remove('hidden');

                    pollBatchProgress(batchId, totalChapters || data.total);
                } else if (data.status === 'completed') {
                    // Show completion message briefly
                    const statusDiv = document.getElementById('illustration-status');
                    statusDiv.textContent = '✓ Generated ' + data.completed + ' illustrations!';
                    statusDiv.classList.add('!text-green-600');
                    statusDiv.classList.remove('hidden');

                    // Update TOC icons and clear
                    setTimeout(() => {
                        updateTOCIcons();
                        statusDiv.classList.add('hidden');
                        statusDiv.classList.remove('!text-green-600');
                    }, 3000);

                    // Clear localStorage
                    localStorage.removeItem('activeBatchId_' + bookId);
                    localStorage.removeItem('activeBatchTotal_' + bookId);
                } else {
                    // Batch not found or error - clear localStorage
                    localStorage.removeItem('activeBatchId_' + bookId);
                    localStorage.removeItem('activeBatchTotal_' + bookId);
                }
            } catch (error) {
                console.error('[DEBUG] Error checking batch status:', error);
            }
        }

        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        // Illustrations availability map (chapter_index -> has_illustrations)
        const illustrationsMap = {{ illustrations_map | tojson | safe }};

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "/read/{{ book_id }}/" + idx;
                // If there was an anchor, we could try to scroll to it,
                // but simple page loads often lose anchor position without extra JS.
                // Let's just go to the page.
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        // Update TOC icons based on illustration availability
        function updateTOCIcons() {
            console.log('[DEBUG] Updating TOC illustration icons...');
            const tocLinks = document.querySelectorAll('.toc-link');

            tocLinks.forEach(link => {
                const fileHref = link.getAttribute('data-file-href');
                const cleanFile = fileHref.split('#')[0];
                const chapterIdx = spineMap[cleanFile];

                if (chapterIdx !== undefined) {
                    const hasIllustrations = illustrationsMap[chapterIdx];
                    const icon = link.querySelector('.illustration-icon');

                    if (icon) {
                        if (hasIllustrations) {
                            icon.classList.remove('hidden');
                        } else {
                            icon.classList.add('hidden');
                        }
                    }
                }
            });

            console.log('[DEBUG] TOC icons updated');
        }

        // Update icons on page load
        document.addEventListener('DOMContentLoaded', updateTOCIcons);

        // Check for active batch generation on page load
        document.addEventListener('DOMContentLoaded', checkActiveBatchGeneration);

        // Illustration generation
        const bookId = "{{ book_id }}";
        const chapterIndex = {{ chapter_index }};
        const hasIllustrations = {{ 'true' if has_illustrations else 'false' }};

        // Check illustration status on load
        async function checkIllustrationStatus() {
            console.log('[DEBUG] Checking illustration status for chapter', chapterIndex);
            try {
                const response = await fetch(`/read/${bookId}/${chapterIndex}/illustration-status`);
                console.log('[DEBUG] Status response:', response.status, response.statusText);
                const data = await response.json();
                console.log('[DEBUG] Status data:', JSON.stringify(data, null, 2));

                const btn = document.getElementById('generate-illustrations-btn');

                if (data.has_illustrations) {
                    const btnText = document.getElementById('illustration-btn-text');
                    if (btnText) {
                        btnText.textContent = 'Regenerate Illustrations';
                    }
                }
            } catch (error) {
                console.error('[DEBUG] Error checking illustration status:', error);
            }
        }

        async function generateIllustrations() {
            console.log('[DEBUG] ===== Starting illustration generation =====');
            console.log('[DEBUG] Book ID:', bookId);
            console.log('[DEBUG] Chapter Index:', chapterIndex);

            const btn = document.getElementById('generate-illustrations-btn');
            const btnText = document.getElementById('illustration-btn-text');
            const statusDiv = document.getElementById('illustration-status');

            // Disable button and show loading
            btn.disabled = true;
            btnText.innerHTML = '<span class="inline-block w-4 h-4 border-2 border-gray-200 border-t-primary rounded-full animate-spin mr-2"></span>Generating...';
            statusDiv.textContent = 'Generating (0/3)...';
            statusDiv.classList.remove('hidden');

            try {
                const url = `/read/${bookId}/${chapterIndex}/generate-illustrations`;
                console.log('[DEBUG] POST request to:', url);

                const response = await fetch(url, {
                    method: 'POST'
                });

                console.log('[DEBUG] Response status:', response.status, response.statusText);
                console.log('[DEBUG] Response headers:', Object.fromEntries(response.headers.entries()));

                const responseData = await response.json().catch(async () => {
                    const text = await response.text();
                    return { text };
                });
                console.log('[DEBUG] Response data:', JSON.stringify(responseData, null, 2));

                if (response.ok) {
                    console.log('[DEBUG] Generation started, beginning polling...');
                    // Poll for completion
                    let attempts = 0;
                    const maxAttempts = 180; // 180 seconds (3 minutes) - generation can take a while

                    const pollInterval = setInterval(async () => {
                        attempts++;
                        console.log(`[DEBUG] Polling attempt ${attempts}/${maxAttempts}`);
                        try {
                            const statusResponse = await fetch(`/read/${bookId}/${chapterIndex}/illustration-status`);
                            const statusData = await statusResponse.json();
                            console.log(`[DEBUG] Poll ${attempts} - Status:`, JSON.stringify(statusData, null, 2));

                            // Update progress indicator with current image count
                            if (statusData.status === 'generating' && statusData.current_image_count !== undefined) {
                                const progress = statusData.current_image_count || 0;
                                statusDiv.textContent = `Generating (${progress}/3)...`;
                                console.log(`[DEBUG] Progress update: ${progress}/3 images`);
                            }

                            // Check for error status
                            if (statusData.status === 'error') {
                                console.log('[DEBUG] ✗ Generation failed with error');
                                clearInterval(pollInterval);
                                btn.disabled = false;
                                btnText.textContent = 'Generate Illustrations';
                                statusDiv.textContent = `✗ Error: ${statusData.error || 'Generation failed'}`;
                                statusDiv.classList.add('!text-red-600');
                                statusDiv.classList.remove('hidden');
                                // Keep error visible for longer
                                setTimeout(() => {
                                    statusDiv.classList.add('hidden');
                                    statusDiv.classList.remove('!text-red-600');
                                }, 10000);
                            }
                            // Check that we have all 3 illustrations (not just some)
                            else if (statusData.has_illustrations && statusData.image_count === 3) {
                                console.log('[DEBUG] ✓ All 3 illustrations found! Stopping poll.');
                                clearInterval(pollInterval);
                                statusDiv.textContent = `✓ ${statusData.image_count} generated!`;
                                statusDiv.classList.add('!text-green-600');
                                // Refresh page after showing toast briefly
                                setTimeout(() => {
                                    window.location.reload();
                                }, 1500);
                            } else if (attempts >= maxAttempts) {
                                console.log('[DEBUG] Max attempts reached, stopping poll.');
                                clearInterval(pollInterval);
                                btn.disabled = false;
                                btnText.textContent = 'Generate Illustrations';
                                statusDiv.textContent = 'Timeout - refresh page';
                                statusDiv.classList.add('!text-orange-600');
                            }
                        } catch (error) {
                            console.error('[DEBUG] Error polling status:', error);
                        }
                    }, 1000);
                } else {
                    console.error('[DEBUG] Response not OK:', response.status, responseData);
                    throw new Error(`Failed to start generation: ${response.status} - ${JSON.stringify(responseData)}`);
                }
            } catch (error) {
                console.error('[DEBUG] ===== Error generating illustrations =====');
                console.error('[DEBUG] Error details:', error);
                console.error('[DEBUG] Error stack:', error.stack);
                btn.disabled = false;
                btnText.textContent = 'Generate Illustrations';
                statusDiv.textContent = `✗ Error: ${error.message || 'Failed to start generation'}`;
                statusDiv.classList.add('!text-red-600');
                statusDiv.classList.remove('hidden');
                // Keep error visible
                setTimeout(() => {
                    statusDiv.classList.add('hidden');
                    statusDiv.classList.remove('!text-red-600');
                }, 10000);
            }
        }

        // Check status on page load
        checkIllustrationStatus();

        // Export chapter function
        function exportChapter() {
            window.location.href = `/read/${bookId}/${chapterIndex}/export`;
        }

        // ============= TTS FUNCTIONALITY =============

        // TTS global state
        const ttsCache = new Map();  // Map para_hash -> audio_path
        let currentAudio = null;     // Current playing audio element

        // Initialize TTS on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeTTS();
        });

        function initializeTTS() {
            console.log('[TTS DEBUG] Initializing TTS for paragraphs...');

            // Find all paragraphs in book content
            const paragraphs = document.querySelectorAll('.book-content p');
            console.log(`[TTS DEBUG] Found ${paragraphs.length} paragraphs`);

            let buttonCount = 0;
            paragraphs.forEach((para, index) => {
                // Skip empty paragraphs
                const text = para.textContent.trim();
                if (!text || text.length < 10) {
                    return;
                }

                // Skip if already wrapped (in case of re-initialization)
                if (para.parentElement.classList.contains('group')) {
                    return;
                }

                // Create wrapper div with Tailwind group class
                const wrapper = document.createElement('div');
                wrapper.className = 'group relative mb-6 pr-10 -mr-10';

                // Replace paragraph with wrapper, then put paragraph inside wrapper
                para.parentNode.insertBefore(wrapper, para);
                wrapper.appendChild(para);

                // Create play button with Tailwind classes
                const playBtn = document.createElement('button');
                playBtn.className = 'tts-play-btn hidden group-hover:flex items-center justify-center absolute right-1.5 top-1/2 -translate-y-1/2 w-7 h-7 bg-primary rounded-full shadow-md hover:bg-primary-dark hover:scale-110 transition-all z-10';
                playBtn.setAttribute('title', 'Play audio');

                // Create play icon (triangle)
                const playIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                playIcon.setAttribute('class', 'play-icon w-3 h-3 ml-0.5');
                playIcon.setAttribute('viewBox', '0 0 12 14');
                playIcon.setAttribute('fill', 'none');
                playIcon.innerHTML = '<path d="M0 0L12 7L0 14V0Z" fill="white"/>';

                // Create pause icon (two bars)
                const pauseIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                pauseIcon.setAttribute('class', 'pause-icon hidden w-3 h-3');
                pauseIcon.setAttribute('viewBox', '0 0 10 14');
                pauseIcon.setAttribute('fill', 'none');
                pauseIcon.innerHTML = '<rect width="3" height="14" fill="white" rx="0.5"/><rect x="7" width="3" height="14" fill="white" rx="0.5"/>';

                // Create loading icon (ellipsis)
                const loadingIcon = document.createElement('span');
                loadingIcon.className = 'loading-icon hidden text-white text-lg';
                loadingIcon.textContent = '⋯';

                // Append all icons to button
                playBtn.appendChild(playIcon);
                playBtn.appendChild(pauseIcon);
                playBtn.appendChild(loadingIcon);

                playBtn.onclick = (e) => {
                    e.stopPropagation();
                    handleTTSClick(playBtn, text);
                };

                // Add button to wrapper (not paragraph)
                wrapper.appendChild(playBtn);
                wrapper.setAttribute('data-tts-enabled', 'true');
                buttonCount++;
            });

            console.log(`[TTS DEBUG] Added ${buttonCount} TTS buttons`);
        }

        // Generate hash for paragraph text (client-side)
        async function generateSimpleHash(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);

            // Use SHA-256 (MD5 not available in browsers, but we'll use first 16 chars)
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            // Take first 16 characters to match backend MD5 length
            return hashHex.substring(0, 16);
        }

        async function handleTTSClick(button, text) {
            console.log('[TTS DEBUG] TTS button clicked');

            // If already playing this paragraph, stop it
            if (currentAudio && button.classList.contains('playing')) {
                console.log('[TTS DEBUG] Stopping current audio');
                stopCurrentAudio();
                return;
            }

            // Stop any other playing audio
            if (currentAudio) {
                console.log('[TTS DEBUG] Stopping other audio');
                stopCurrentAudio();
            }

            // Generate hash for this paragraph
            const paraHash = await generateSimpleHash(text);
            console.log(`[TTS DEBUG] Paragraph hash: ${paraHash}`);

            // Check cache first
            if (ttsCache.has(paraHash)) {
                console.log('[TTS DEBUG] Found in cache');
                playAudio(button, ttsCache.get(paraHash));
                return;
            }

            // Show loading state
            button.classList.add('!flex', 'bg-gray-400');
            button.classList.remove('bg-primary');
            button.querySelector('.play-icon').classList.add('hidden');
            button.querySelector('.loading-icon').classList.remove('hidden');
            button.setAttribute('title', 'Generating audio...');

            try {
                // Request TTS generation
                console.log('[TTS DEBUG] Requesting TTS generation...');
                const response = await fetch(`/read/${bookId}/generate-tts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[TTS DEBUG] Response:', data);

                if (data.status === 'cached') {
                    // Audio already available
                    console.log('[TTS DEBUG] Audio was cached on server');
                    ttsCache.set(paraHash, data.audio_path);
                    playAudio(button, data.audio_path);
                } else if (data.status === 'generating') {
                    // Poll for completion
                    console.log('[TTS DEBUG] Starting polling for generation...');
                    pollTTSStatus(button, data.para_hash);
                }
            } catch (error) {
                console.error('[TTS ERROR] TTS generation error:', error);
                button.classList.remove('!flex', 'bg-gray-400');
                button.classList.add('bg-primary');
                button.querySelector('.loading-icon').classList.add('hidden');
                button.querySelector('.play-icon').classList.remove('hidden');
                button.setAttribute('title', 'Error generating audio');
                // Show error state briefly
                button.classList.add('bg-red-500');
                setTimeout(() => {
                    button.classList.remove('bg-red-500');
                    button.classList.add('bg-primary');
                }, 2000);
            }
        }

        async function pollTTSStatus(button, paraHash) {
            const maxAttempts = 30;  // 30 seconds max
            let attempts = 0;

            const pollInterval = setInterval(async () => {
                attempts++;
                console.log(`[TTS DEBUG] Polling attempt ${attempts}/${maxAttempts}`);

                try {
                    const response = await fetch(`/read/${bookId}/tts-status/${paraHash}`);
                    const data = await response.json();
                    console.log(`[TTS DEBUG] Poll ${attempts} - Status:`, data);

                    if (data.ready && data.audio_path) {
                        console.log('[TTS DEBUG] Audio ready!');
                        clearInterval(pollInterval);
                        ttsCache.set(paraHash, data.audio_path);
                        playAudio(button, data.audio_path);
                    } else if (attempts >= maxAttempts) {
                        console.log('[TTS DEBUG] Max attempts reached');
                        clearInterval(pollInterval);
                        button.classList.remove('!flex', 'bg-gray-400');
                        button.classList.add('bg-primary');
                        button.querySelector('.loading-icon').classList.add('hidden');
                        button.querySelector('.play-icon').classList.remove('hidden');
                        button.setAttribute('title', 'Generation timeout - try again');
                    }
                } catch (error) {
                    console.error('[TTS ERROR] Polling error:', error);
                    clearInterval(pollInterval);
                    button.classList.remove('!flex', 'bg-gray-400');
                    button.classList.add('bg-primary');
                    button.querySelector('.loading-icon').classList.add('hidden');
                    button.querySelector('.play-icon').classList.remove('hidden');
                }
            }, 1000);
        }

        function playAudio(button, audioPath) {
            console.log('[TTS DEBUG] Playing audio:', audioPath);

            button.classList.remove('bg-gray-400');
            button.classList.add('!flex', 'bg-red-500', 'playing');
            button.querySelector('.loading-icon').classList.add('hidden');
            button.querySelector('.play-icon').classList.add('hidden');
            button.querySelector('.pause-icon').classList.remove('hidden');
            button.setAttribute('title', 'Stop audio');

            // Create and play audio
            currentAudio = new Audio(`/read/${bookId}/${audioPath}`);
            currentAudio.currentButton = button;

            currentAudio.onended = () => {
                console.log('[TTS DEBUG] Audio playback ended');
                button.classList.remove('!flex', 'bg-red-500', 'playing');
                button.classList.add('bg-primary');
                button.querySelector('.pause-icon').classList.add('hidden');
                button.querySelector('.play-icon').classList.remove('hidden');
                button.setAttribute('title', 'Play audio');
                currentAudio = null;
            };

            currentAudio.onerror = (e) => {
                console.error('[TTS ERROR] Audio playback error:', e);
                button.classList.remove('!flex', 'bg-red-500', 'playing');
                button.classList.add('bg-primary');
                button.querySelector('.pause-icon').classList.add('hidden');
                button.querySelector('.play-icon').classList.remove('hidden');
                button.setAttribute('title', 'Playback error');
                currentAudio = null;
            };

            currentAudio.play().catch(err => {
                console.error('[TTS ERROR] Audio play error:', err);
                button.classList.remove('!flex', 'bg-red-500', 'playing');
                button.classList.add('bg-primary');
                button.querySelector('.pause-icon').classList.add('hidden');
                button.querySelector('.play-icon').classList.remove('hidden');
            });
        }

        function stopCurrentAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                if (currentAudio.currentButton) {
                    currentAudio.currentButton.classList.remove('!flex', 'bg-red-500', 'bg-gray-400', 'playing');
                    currentAudio.currentButton.classList.add('bg-primary');
                    currentAudio.currentButton.querySelector('.pause-icon').classList.add('hidden');
                    currentAudio.currentButton.querySelector('.loading-icon').classList.add('hidden');
                    currentAudio.currentButton.querySelector('.play-icon').classList.remove('hidden');
                    currentAudio.currentButton.setAttribute('title', 'Play audio');
                }
                currentAudio = null;
            }
        }
    </script>
</body>
</html>
